package com.ict11.test;

public class Ex01 {
	
	// 문제1. public static void main(String[] args) {
	// 문제2. boolean, byte, short, char, int, long, float, double
	// 문제3. byte로 형변환
	//	int intVar = 129;
	//	byte byteVar = (byte)intVar;
	// 문제4. a++, ++a 차이점
	// 	~~
	// 문제5. double s1 = 36.66666 소수점 첫재까지
	//	double s1 = 36.66666;
	//	double k1 = (int)(s1*10)/10.0;
	//	System.out.println(k1);
	
	
	// 문제6. 클래스는 무엇으로 이루어졌는지? 3가지
	//	멤버필드(변수와 상수), 멤버메소드, 생성자
	// 문제7. 생성자 => 초기화를 목적으로 반드시 호출
	// 문제8. 오버로딩(=중복정의)
	// 문제9. 오버라이딩(=재정의)
	// 문제10. 추상클래스와 인터페이스에 대해 작성
	//	추상클래스: 추상메소드를 하나이상 가지고 있는 클래스
	//		추상메소드: body(구체화)가 없는 메소드, 구체화되지 않은 메소드
	//	인터페이스: 상수와 추상메소드로 이루어진 클래스, 
	//				생성자가 없고 객체 생성을 할 수 없다.
	
	
	// 문제11. 랜덤클래스로 1-10 난수구하기
	//	Random random = new Random();
	//	int k1 = random.nextInt(10)+1;
	//	int k2 = (int)(random.nextDouble()*10)+1;
	//	System.out.println(k1 or k2);
	// 문제12. 제네닉과 컬렉션
	//	제네닉: 컬렉션이 어떤 객체들로 이루어졌는 지 표시하는 객체타입
	//	컬렉션: 객체를 모아서 관리하는 인터페이스를 구현한 것
	// 			(=객체를 모아서 관리하는 자료구조)
	// 문제13. 스레드 클래스와 Runnable 인터페이스의 차이
	//	스레드 클래스: start()와 run()가 둘 다 존재
	//	Runnable 인터페이스: run()만 존재 => start()가 없으므로 
	//		별도의 스레드를 생성해서 run()를 가진 클래스를 타겟으로 잡야아 한다.
	// 문제14. 동기화처리란?
	//	멀티스레드에서 공통으로 사용되는 영역(임계영역)에서 현재 실행중인
	//	스레드가 순식간에 다른 스레드에게 제어권을 뺏기는 문제가 발생한다.
	//	이를 해결하기 위한 방법이 동기화 처리이다.
	//	해당 임계영역에 synchronized 예약어를 사용하면 된다.
	// 문제15. 바이트스트림과 문자스트림의 차이
	//	바이트 스트림(기계중심): 모든 처리를 1byte씩 처리
	//		대상: 1byte로 이루어진 파일들 (영상, 소리, 사진 등 모든 파일들)
	//	    영문자 대소문자, 숫자를 스트림 할 수 있다.(영문 이외의 문자 불가)
	//		최상위 클래스: InputStream(입력), OutputStream(출력)
	//	문자 스트림(사람중심): 모든 처리를 2byte씩 처리
	//		대상: 전 세계의 모든 언어로 구성된 문서 파일
	//		최상위 클래스: Reader(입력), Writer(출력)
}
